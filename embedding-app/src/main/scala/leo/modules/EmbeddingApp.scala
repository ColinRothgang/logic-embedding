package leo.modules

import leo.datastructures.TPTP
import leo.datastructures.TPTP.{AnnotatedFormula, Problem}
import leo.modules.embeddings.Embedding
import leo.modules.input.TPTPParser

import java.io.{File, FileNotFoundException, PrintWriter}
import scala.io.Source

object EmbeddingApp {
  final val name: String = "embed"
  final val version: Double = 0.1

  private[this] var inputFileName = ""
  private[this] var outputFileName: Option[String] = None
  private[this] var logic: Option[String] = None
  private[this] var parameterNames: Set[String] = Set.empty
  private[this] var specs: Map[String, String] = Map.empty

  private[this] val embeddingTable: Map[String, Embedding] = {
    import leo.modules.embeddings.ModalEmbedding
    Map(
      "modal" -> ModalEmbedding
    )
  }

  final def main(args: Array[String]): Unit = {
    if (args.contains("--help")) {
      usage(); return
    }
    if (args.contains("--version")) {
      printVersion(); return
    }
    if (args.isEmpty) usage()
    else {
      var infile: Option[Source] = None
      var outfile: Option[PrintWriter] = None
      var error: Boolean = false
      try {
        parseArgs(args.toSeq)
        // Read input
        infile = Some(if (inputFileName == "-") io.Source.stdin else io.Source.fromFile(inputFileName))
        // Parse and select embedding
        val parsedInput = TPTPParser.problem(infile.get)
        val goalLogic = getLogic(parsedInput)
        val embeddingFunction = try {
          embeddingTable(goalLogic)
        } catch {
          case _: NoSuchElementException => throw new UnsupportedLogicException(goalLogic)
        }
        // Transform embedding parameters
        val parameters = parameterNames.map { p =>
          try {
            embeddingFunction.embeddingParameter.withName(p)
          } catch {
            case _: NoSuchElementException => throw new UnknownParameterException(p, embeddingFunction.embeddingParameter.values.mkString(","))
          }
        }
        // Do embedding
        // TODO: Prepend logic spec if necessary
        val embeddedFormulas = embeddingFunction.apply(parsedInput.formulas, parameters.asInstanceOf[Set[embeddingFunction.OptionType#Value]]) // The world is bad
        val embeddedProblem = Problem(parsedInput.includes, embeddedFormulas)
        // Write result
        val result = generateResult(embeddedProblem)
        outfile = Some(if (outputFileName.isEmpty) new PrintWriter(System.out) else new PrintWriter(new File(outputFileName.get)))
        outfile.get.println(result)
        outfile.get.flush()
      } catch {
        case e: IllegalArgumentException =>
          println(e.getMessage)
          usage()
          error = true
        case e: UnsupportedLogicException =>
          println(s"Unsupported logic '${e.logic}'. Aborting.")
          error = true
        case e: UnknownParameterException =>
          println(s"Parameter ${e.parameterName} is unknown.")
          println(s"Valid parameters are: ${e.allowedParameters}")
          error = true
        case e: MalformedLogicSpecificationException =>
          println(s"Logic specification in the input file cannot be interpreted: ${e.spec.pretty}")
          error = true
        case _: UnspecifiedLogicException =>
          println(s"Logic specification not found inside of input file and no explicit logic given via -l. Aborting.")
          error = true
        case e: FileNotFoundException =>
          println(s"File cannot be found or is not readable/writable: ${e.getMessage}")
          error = true
        case e: TPTPParser.TPTPParseException =>
          println(s"Input file could not be parsed, parse error at ${e.line}:${e.offset}: ${e.getMessage}")
          error = true
      } finally {
        infile.foreach(_.close())
        outfile.foreach(_.close())
      }
      if (error) System.exit(1)
    }
  }



  private[this] final def generateResult(problem: Problem): String = {
    import java.util.Calendar

    val sb: StringBuilder = new StringBuilder()
    sb.append(s"%%% This file was generated by semantical embedding via the $name tool, version $version.\n")
    sb.append(s"%%% Generated on ${Calendar.getInstance().getTime.toString}\n")
    sb.append("\n")
    sb.append(problem.pretty)
    sb.toString()
  }

  private[this] final def getLogic(parsedInput: TPTP.Problem): String = {
    parsedInput.formulas.find(f => f.role == "logic") match {
      case Some(value) => getLogicFromSpec(value)
      case None if logic.isDefined => logic.get
      case None => throw new UnspecifiedLogicException
    }
  }

  private[this] final def getLogicFromSpec(formula: AnnotatedFormula): String = {
    import leo.datastructures.TPTP.THF
    formula match {
      case TPTP.THFAnnotated(_, _, THF.Logical(f), _) => f match {
        case THF.BinaryFormula(THF.:=, THF.FunctionTerm(logic, Seq()), _) => if (logic.startsWith("$")) logic.tail else logic
        case _ => throw new MalformedLogicSpecificationException(formula)
      }
      case _ => throw new MalformedLogicSpecificationException(formula)
    }
  }

  private[this] final def printVersion(): Unit = {
    println(s"$name $version")
  }

  private[this] final def usage(): Unit = {
    println(s"usage: $name [-l <logic>] [-p <parameter>] [-s <spec>=<value>] <problem file> [<output file>]")
    println(
      """
        | <problem file> can be either a file name or '-' (without parentheses) for stdin.
        | If <output file> is specified, the result is written to <output file>, otherwise to stdout.
        |
        | Options:
        |  -l <logic>
        |     If <problem file> does not contain a logic specification statement, explicitly set
        |     the input format to <logic>.
        |     Supported <logic>s are: modal
        |
        |  -p <parameter>
        |     Pass transformation parameter <parameter> to the embedding procedure.
        |
        |  -s <spec>=<value>
        |     If <problem file> does not contain a logic specification statement, explicitly set
        |     semantics of <spec> to <value>. In this case, -l needs to be provided.
        |""".stripMargin)
  }

  private[this] final def parseArgs(args: Seq[String]): Any = {
    var args0 = args
    while (args0.nonEmpty) {
      args0 match {
        case Seq("-l", l, rest@_*) =>
          args0 = rest
          logic = Some(l)
        case Seq("-p", p, rest@_*) =>
          args0 = rest
          parameterNames = parameterNames + p
        case Seq("-s", eq, rest@_*) =>
          args0 = rest
          eq.split("=", 2).toSeq match {
            case Seq(l, r) => specs = specs + (l -> r)
            case _ => throw new IllegalArgumentException(s"Malformed argument to -s option: '$eq'")
          }
          specs
        case Seq(f) =>
          args0 = Seq.empty
          inputFileName = f
        case Seq(f, o) =>
          args0 = Seq.empty
          inputFileName = f
          outputFileName = Some(o)
        case _ => throw new IllegalArgumentException("Unrecognized arguments.")
      }
    }
  }

  private[this] class UnknownParameterException(val parameterName: String, val allowedParameters: String) extends RuntimeException
  private[this] class MalformedLogicSpecificationException(val spec: TPTP.AnnotatedFormula) extends RuntimeException
  private[this] class UnspecifiedLogicException extends RuntimeException
  private[this] class UnsupportedLogicException(val logic: String) extends RuntimeException

}
